"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.markerContext = exports.default = void 0;
var React = _interopRequireWildcard(require("react"));
var _reactNative = require("react-native");
var _ReactGoogleMaps = require("./ReactGoogleMaps");
var _MapCallout = _interopRequireDefault(require("./MapCallout"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
const markerContext = /*#__PURE__*/React.createContext({
  pinColor: "#E74C3C",
  calloutOpened: false,
  position: undefined,
  toggleCallout: () => {}
});
exports.markerContext = markerContext;
const MapMarker = _ref => {
  let {
    pinColor,
    latitude,
    longitude,
    title,
    description,
    children
  } = _ref;
  const {
    Provider
  } = markerContext;
  const [calloutOpened, toggleCallout] = React.useState(false);
  const [marker, setMarker] = React.useState(null);
  const handleMarkerClick = () => toggleCallout(true);
  const handleOnLoad = m => setMarker(m);
  if (!_ReactGoogleMaps.Marker) {
    return null;
  }
  let mappedChildren;
  if (!children) {
    if (title || description) {
      mappedChildren = /*#__PURE__*/React.createElement(_MapCallout.default, {
        showTooltip: true,
        anchor: marker
      }, /*#__PURE__*/React.createElement(_reactNative.View, {
        style: style.tooltip
      }, title && /*#__PURE__*/React.createElement(_reactNative.Text, {
        style: style.title
      }, title), description && /*#__PURE__*/React.createElement(_reactNative.Text, {
        style: style.description
      }, description)));
    }
  } else {
    mappedChildren = React.Children.map(children, (child, index) => {
      return /*#__PURE__*/React.cloneElement(child, {
        index,
        anchor: marker
      });
    });
  }
  return /*#__PURE__*/React.createElement(Provider, {
    value: {
      pinColor: pinColor,
      calloutOpened,
      toggleCallout: value => toggleCallout(value),
      position: {
        latitude,
        longitude
      }
    }
  }, /*#__PURE__*/React.createElement(_ReactGoogleMaps.Marker, {
    position: {
      lat: latitude,
      lng: longitude
    },
    onClick: handleMarkerClick,
    onLoad: handleOnLoad
  }, mappedChildren));
};
const style = _reactNative.StyleSheet.create({
  tooltip: {
    display: "flex",
    flexDirection: "column"
  },
  title: {
    fontWeight: "600",
    textAlign: "center"
  },
  description: {
    textAlign: "center"
  }
});
var _default = MapMarker;
exports.default = _default;